--
-- For use with https://github.com/supabase/supabase/tree/master/examples/slack-clone/nextjs-slack-clone
--

-- Custom types
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_permission') THEN
    CREATE TYPE public.app_permission AS ENUM ('channels.delete', 'messages.delete');
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_role') THEN
    CREATE TYPE public.app_role AS ENUM ('admin', 'moderator');
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_status') THEN
    CREATE TYPE public.user_status AS ENUM ('ONLINE', 'OFFLINE');
  END IF;
END$$;

-- USERS
CREATE TABLE IF NOT EXISTS public.users (
  id          uuid REFERENCES auth.users NOT NULL PRIMARY KEY, -- UUID from auth.users
  username    text,
  status      user_status DEFAULT 'OFFLINE'::public.user_status
);
COMMENT ON TABLE public.users IS 'Profile data for each user.';
COMMENT ON COLUMN public.users.id IS 'References the internal Supabase Auth user.';

-- CHANNELS
CREATE TABLE IF NOT EXISTS public.channels (
  id            bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  inserted_at   timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  slug          text NOT NULL UNIQUE,
  created_by    uuid REFERENCES public.users NOT NULL
);
COMMENT ON TABLE public.channels IS 'Topics and groups.';

-- MESSAGES
CREATE TABLE IF NOT EXISTS public.messages (
  id            bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  inserted_at   timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  message       text,
  user_id       uuid REFERENCES public.users NOT NULL,
  channel_id    bigint REFERENCES public.channels ON DELETE CASCADE NOT NULL
);
COMMENT ON TABLE public.messages IS 'Individual messages sent by each user.';

-- USER ROLES
CREATE TABLE IF NOT EXISTS public.user_roles (
  id        bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id   uuid REFERENCES public.users ON DELETE CASCADE NOT NULL,
  role      app_role NOT NULL,
  UNIQUE (user_id, role)
);
COMMENT ON TABLE public.user_roles IS 'Application roles for each user.';

-- ROLE PERMISSIONS
CREATE TABLE IF NOT EXISTS public.role_permissions (
  id           bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role         app_role NOT NULL,
  permission   app_permission NOT NULL,
  UNIQUE (role, permission)
);
COMMENT ON TABLE public.role_permissions IS 'Application permissions for each role.';

-- Authorize with role-based access control (RBAC)
CREATE OR REPLACE FUNCTION public.authorize(
  requested_permission app_permission
)
RETURNS boolean AS $$
DECLARE
  bind_permissions int;
BEGIN
  SELECT count(*)
  FROM public.role_permissions
  WHERE role_permissions.permission = authorize.requested_permission
    AND role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_role
  INTO bind_permissions;
  
  RETURN bind_permissions > 0;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- Secure the tables
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.channels ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;

-- Policies for public.users
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE policyname = 'Allow logged-in read access' AND tablename = 'users'
  ) THEN
    CREATE POLICY "Allow logged-in read access" ON public.users FOR SELECT USING ( auth.role() = 'authenticated' );
  END IF;
END$$;

-- Repeat similar DO blocks for each policy creation to check existence

-- Send "previous data" on change 
ALTER TABLE public.users REPLICA IDENTITY FULL; 
ALTER TABLE public.channels REPLICA IDENTITY FULL; 
ALTER TABLE public.messages REPLICA IDENTITY FULL;

-- Function to handle new users
CREATE OR REPLACE FUNCTION public.handle_new_user() 
RETURNS trigger AS $$
DECLARE
  is_admin boolean;
BEGIN
  INSERT INTO public.users (id, username)
  VALUES (new.id, new.email)
  ON CONFLICT DO NOTHING;

  -- Only attempt to assign roles if the user has an email
  IF new.email IS NOT NULL THEN
    IF position('+supaadmin@' in new.email) > 0 THEN
      INSERT INTO public.user_roles (user_id, role) VALUES (new.id, 'admin')
      ON CONFLICT DO NOTHING;
    ELSIF position('+supamod@' in new.email) > 0 THEN
      INSERT INTO public.user_roles (user_id, role) VALUES (new.id, 'moderator')
      ON CONFLICT DO NOTHING;
    END IF;
  END IF;

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = auth, public;

-- Trigger to call handle_new_user function
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Realtime subscriptions setup
BEGIN; 
  -- Remove the realtime publication
  DROP PUBLICATION IF EXISTS supabase_realtime; 

  -- Re-create the publication but don't enable it for any tables
  CREATE PUBLICATION supabase_realtime;  
COMMIT;

-- Add tables to the publication
ALTER PUBLICATION supabase_realtime ADD TABLE public.channels;
ALTER PUBLICATION supabase_realtime ADD TABLE public.messages;
ALTER PUBLICATION supabase_realtime ADD TABLE public.users;

-- Helper functions
CREATE OR REPLACE FUNCTION public.create_user(
    email text
) RETURNS uuid
    SECURITY DEFINER
    SET search_path = auth
AS $$
  DECLARE
    user_id uuid;
BEGIN
  user_id := extensions.uuid_generate_v4();
  
  INSERT INTO auth.users (id, email)
    VALUES (user_id, email)
    ON CONFLICT DO NOTHING
    RETURNING id INTO user_id;

  RETURN user_id;
END;
$$ LANGUAGE plpgsql;

-- Policies for anonymous users
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE policyname = 'Allow anonymous select access' AND tablename = 'users'
  ) THEN
    CREATE POLICY "Allow anonymous select access" ON public.users
    FOR SELECT
    USING ( auth.uid() = id );
  END IF;
END$$;

-- Repeat similar DO blocks for other policies on 'users' table

